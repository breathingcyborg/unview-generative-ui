// Generated by LLM - ideally tools should call your api or you could use mcp

import { z } from 'zod';
import { AddressSchema, CustomerSchema, InventoryItemSchema, OrderItemSchema, ProductSchema, OrderSchema, PromotionSchema, ShipmentSchema, SupplierSchema, WarehouseSchema } from './entities';
import { generateObject, tool } from 'ai';
import { getDataGenerationLLM } from './llms';


// --- Common Schema for Basic Item Info ---
const OrderItemBasicInfoSchema = z.object({
    product_id: ProductSchema.shape.product_id,
    product_name: ProductSchema.shape.name,
    sku: ProductSchema.shape.sku,
    quantity: z.number().int().positive().describe('Quantity of this product.'),
});


// --- A. Inventory Manager Tools ---

// 1. getLowStockProducts
const GetLowStockProductsInputSchema = z.object({
    warehouse_id: z.string().optional().nullable().describe('Optional: Filter by specific warehouse ID. If not provided, check all warehouses.'),
    threshold_quantity: z.number().int().positive().nullable().optional().describe('Optional: Override product reorder_level if this is provided.'),
    limit: z.number().int().positive().optional().nullable().default(10).describe('Maximum number of low stock products to return.'),
});

const GetLowStockProductsOutputSchema = z.object({
    items: z.array(z.object({
        product_id: ProductSchema.shape.product_id,
        product_name: ProductSchema.shape.name,
        sku: ProductSchema.shape.sku,
        warehouse_id: WarehouseSchema.shape.warehouse_id,
        warehouse_name: WarehouseSchema.shape.name,
        quantity_on_hand: InventoryItemSchema.shape.quantity_on_hand,
        reorder_level: InventoryItemSchema.shape.reorder_level,
        supplier_name: SupplierSchema.shape.name,
        supplier_id: SupplierSchema.shape.supplier_id,
        average_lead_time_days: SupplierSchema.shape.average_lead_time_days,
    }))
});

const getLowStockProductsTool = tool({
    type: 'function',
    description: "Retrieves a list of products with stock levels below or at their reorder point, or below a specified threshold. Useful for identifying urgent reordering needs.",
    parameters: GetLowStockProductsInputSchema,
    execute: async (input_params) => {
        console.debug("input", input_params);
        const { object: generatedData } = await generateObject({
            model: getDataGenerationLLM(), // Replace with your actual model instance
            schema: GetLowStockProductsOutputSchema,
            prompt: `Generate a list of ${input_params.limit || 10} fake products that are low on stock.
        ${input_params.warehouse_id ? `Consider them for warehouse ${input_params.warehouse_id}.` : ''}
        ${input_params.threshold_quantity ? `Their quantity on hand should be around or below ${input_params.threshold_quantity}.` : 'Their quantity on hand should be near or below their reorder level.'}
        Ensure data plausibility for an e-commerce inventory manager. Include supplier details.`,
        });
        console.debug("output", generatedData);
        return generatedData;
    },
});

// 2. getInventorySummary
const GetInventorySummaryInputSchema = z.object({
    warehouse_id: z.string().optional().describe('Optional: Filter by specific warehouse ID. If not provided, summarize all warehouses.'),
});

const GetInventorySummaryOutputSchema = z.object({
    total_distinct_products: z.number().int().nonnegative().describe('Total number of unique product types in inventory.'),
    total_units_on_hand: z.number().int().nonnegative().describe('Total count of all units of all products in stock.'),
    total_inventory_value_cost: z.number().nonnegative().describe('Total cost value of all inventory on hand.'),
    products_below_reorder_level_count: z.number().int().nonnegative().describe('Number of products currently below their reorder level.'),
    products_out_of_stock_count: z.number().int().nonnegative().describe('Number of products completely out of stock (quantity 0).'),
    potential_dead_stock_value: z.number().nonnegative().describe('Estimated cost value of stock that has not sold for a long period (e.g., >180 days).'),
    last_updated: z.string().datetime().describe('Timestamp of when this summary was generated.'),
});

const getInventorySummaryTool = tool({
    type: 'function',
    description: "Provides a high-level summary of inventory status, like total items, total value, and items needing attention. Good for a quick overview.",
    parameters: GetInventorySummaryInputSchema,
    execute: async (input_params) => {
        const { object: generatedData } = await generateObject({
            model: getDataGenerationLLM(), // Replace
            schema: GetInventorySummaryOutputSchema,
            prompt: `Generate a fake inventory summary for an e-commerce store.
        ${input_params.warehouse_id ? `This summary should reflect inventory for warehouse ${input_params.warehouse_id}.` : 'This summary should reflect overall inventory.'}
        Make the numbers plausible (e.g., total units > distinct products).
        Include a 'potential_dead_stock_value' and ensure 'last_updated' is a current timestamp.`,
        });
        return generatedData;
    },
});


// 3. getProductStockDetails
const GetProductStockDetailsInputSchema = z.object({
    product_id: z.string().describe('The ID of the product to get stock details for.'),
});

const GetProductStockDetailsOutputSchema = z.object({
    product_id: ProductSchema.shape.product_id,
    product_name: ProductSchema.shape.name,
    sku: ProductSchema.shape.sku,
    total_quantity_on_hand_all_warehouses: InventoryItemSchema.shape.quantity_on_hand,
    stock_by_warehouse: z.array(z.object({
        warehouse_id: WarehouseSchema.shape.warehouse_id,
        warehouse_name: WarehouseSchema.shape.name,
        quantity_on_hand: InventoryItemSchema.shape.quantity_on_hand,
        location_in_warehouse: InventoryItemSchema.shape.location_in_warehouse.optional(),
    })).describe('Detailed stock levels for this product in each warehouse it is present.'),
    supplier_name: SupplierSchema.shape.name.optional().describe('Name of the primary supplier for this product.'),
    next_expected_delivery_date: InventoryItemSchema.shape.next_expected_delivery_date.optional().describe('If a restock is coming, when it is expected.'),
});

const getProductStockDetailsTool = tool({
    type: 'function',
    description: "Gets detailed stock information for a specific product across all warehouses where it might be stored.",
    parameters: GetProductStockDetailsInputSchema,
    execute: async (input_params) => {
        const { object: generatedData } = await generateObject({
            model: getDataGenerationLLM(), // Replace
            schema: GetProductStockDetailsOutputSchema,
            prompt: `Generate fake detailed stock information for product ID '${input_params.product_id}'.
              Show its stock distributed across 1 to 3 fake warehouses.
              Include a plausible product name, SKU, supplier, and optionally a next expected delivery date.
              The total quantity should sum up from the individual warehouse quantities.`,
        });
        return generatedData;
    },
});

// 4. getSupplierPerformanceMetrics
const GetSupplierPerformanceMetricsInputSchema = z.object({
    supplier_id: z.string().optional().describe('Optional: Get metrics for a specific supplier. If omitted, return for top N suppliers.'),
    limit: z.number().int().positive().optional().default(5).describe('If supplier_id is omitted, number of top suppliers to return metrics for.'),
});

const GetSupplierPerformanceMetricsOutputSchema = z.object({
    items: z.array(z.object({
        supplier_id: SupplierSchema.shape.supplier_id,
        supplier_name: SupplierSchema.shape.name,
        on_time_delivery_rate_percentage: z.number().min(0).max(100).describe('Percentage of deliveries received on time from this supplier.'),
        average_lead_time_days_actual: z.number().positive().describe('Actual average lead time experienced recently.'),
        quality_acceptance_rate_percentage: z.number().min(0).max(100).describe('Percentage of items from supplier passing quality checks.'),
        total_orders_placed_last_90_days: z.number().int().nonnegative().describe('Number of purchase orders placed with this supplier in the last 90 days.'),
    }))
});

const getSupplierPerformanceMetricsTool = tool({
    type: 'function',
    description: "Retrieves performance metrics for suppliers, such as on-time delivery rate and item quality. Useful for supplier evaluation.",
    parameters: GetSupplierPerformanceMetricsInputSchema,
    execute: async (input_params) => {
        const { object: generatedData } = await generateObject({
            model: getDataGenerationLLM(), // Replace
            schema: GetSupplierPerformanceMetricsOutputSchema,
            prompt: `Generate fake performance metrics for ${input_params.supplier_id ? 'supplier ' + input_params.supplier_id : (input_params.limit || 5) + ' top suppliers'}.
              Include plausible on-time delivery rates, actual lead times, quality acceptance rates, and order volumes.
              Make the data look realistic for an e-commerce business evaluating its suppliers.`,
        });
        return generatedData;
    },
});


// --- B. Sales Manager Tools ---

// 1. getSalesPerformanceSummary
const GetSalesPerformanceSummaryInputSchema = z.object({
    period_start_date: z.string().date().describe('Start date for the sales period (YYYY-MM-DD).'),
    period_end_date: z.string().date().describe('End date for the sales period (YYYY-MM-DD).'),
    region: z.string().optional().describe('Optional: Filter by sales region (e.g., North America, EU).'),
    category: z.string().optional().describe('Optional: Filter by product category.'),
});

const GetSalesPerformanceSummaryOutputSchema = z.object({
    total_revenue: z.number().nonnegative().describe('Total revenue generated in the period.'),
    total_orders: z.number().int().nonnegative().describe('Total number of orders placed.'),
    average_order_value: z.number().nonnegative().describe('Average value per order.'),
    new_customers_acquired: z.number().int().nonnegative().describe('Number of new customers acquired during the period.'),
    top_performing_category: z.string().describe('The product category with the highest sales in this period.'),
    conversion_rate: z.number().min(0).max(100).optional().describe('Overall website/sales conversion rate percentage for the period.'),
});

const getSalesPerformanceSummaryTool = tool({
    type: 'function',
    description: "Provides a summary of sales performance over a specified period. Essential for understanding business health.",
    parameters: GetSalesPerformanceSummaryInputSchema,
    execute: async (input_params) => {
        const { object: generatedData } = await generateObject({
            model: getDataGenerationLLM(), // Replace
            schema: GetSalesPerformanceSummaryOutputSchema,
            prompt: `Generate a fake sales performance summary for an e-commerce store.
        The period is from ${input_params.period_start_date} to ${input_params.period_end_date}.
        ${input_params.region ? `Focus on region: ${input_params.region}.` : ''}
        ${input_params.category ? `Focus on category: ${input_params.category}.` : ''}
        Include plausible figures for revenue, orders, AOV, new customers, top category, and optionally conversion rate.`,
        });
        return generatedData;
    },
});

// 2. getTopPerformingProductsBySales
const GetTopPerformingProductsBySalesInputSchema = z.object({
    period_start_date: z.string().date().describe('Start date for the period (YYYY-MM-DD).'),
    period_end_date: z.string().date().describe('End date for the period (YYYY-MM-DD).'),
    metric: z.enum(['revenue', 'units_sold']).describe('Metric to rank products by: "revenue" or "units_sold".'),
    limit: z.number().int().positive().optional().default(10).describe('Number of top products to return.'),
    category: z.string().optional().describe('Optional: Filter by product category.'),
});

const GetTopPerformingProductsBySalesOutputSchema = z.object({
    items: z.array(z.object({
        product_id: ProductSchema.shape.product_id,
        product_name: ProductSchema.shape.name,
        sku: ProductSchema.shape.sku,
        total_revenue_generated: z.number().nonnegative().describe('Total revenue from this product in the period.'),
        total_units_sold: z.number().int().nonnegative().describe('Total units of this product sold in the period.'),
        profit_margin_estimate_percentage: z.number().min(-100).max(100).optional().describe('Estimated profit margin for this product.'), // Can be negative
    }))
});

const getTopPerformingProductsBySalesTool = tool({
    type: 'function',
    description: "Lists top-performing products based on revenue or units sold in a given period. Helps identify key products.",
    parameters: GetTopPerformingProductsBySalesInputSchema,
    execute: async (input_params) => {
        const { object: generatedData } = await generateObject({
            model: getDataGenerationLLM(), // Replace
            schema: GetTopPerformingProductsBySalesOutputSchema,
            prompt: `Generate a list of ${input_params.limit || 10} fake top-performing products for an e-commerce store.
        The period is from ${input_params.period_start_date} to ${input_params.period_end_date}.
        Rank them by ${input_params.metric}.
        ${input_params.category ? `Consider only products in category: ${input_params.category}.` : ''}
        Include plausible revenue, units sold, and an estimated profit margin. Ensure product names are realistic.`,
        });
        return generatedData;
    },
});

// 3. getActivePromotionsOverview
const GetActivePromotionsOverviewInputSchema = z.object({
    promotion_id: z.string().optional().describe('Optional: Get details for a specific active promotion. If omitted, list all active promotions.'),
});

const ActivePromotionDetailSchema = z.object({
    promotion_id: PromotionSchema.shape.promotion_id,
    promotion_name: PromotionSchema.shape.name,
    code: PromotionSchema.shape.code,
    discount_type: PromotionSchema.shape.discount_type,
    discount_value: PromotionSchema.shape.discount_value,
    end_date: PromotionSchema.shape.end_date.describe('When the promotion is scheduled to end.'),
    orders_using_promotion: z.number().int().nonnegative().describe('Number of orders that have used this promotion so far.'),
    revenue_from_promotion: z.number().nonnegative().describe('Total revenue generated from orders using this promotion.'),
    average_items_per_promoted_order: z.number().positive().optional().describe('Average number of items in orders that used this promotion.'),
    top_product_ids_sold_with_promotion: z.array(ProductSchema.shape.product_id).optional().describe('List of product IDs most frequently sold with this promotion.'),
});
const GetActivePromotionsOverviewOutputSchema = z.object({
    items: z.array(ActivePromotionDetailSchema).describe('A list of active promotions. Will contain a single item if promotion_id was specified, or multiple items otherwise.')
});

const getActivePromotionsOverviewTool = tool({
    type: 'function',
    description: "Shows currently active promotions and their performance. Returns an object with an 'items' array. If a promotion_id is given, 'items' will contain details for that one. Otherwise, 'items' lists all active ones.",
    parameters: GetActivePromotionsOverviewInputSchema,
    execute: async (input_params) => {
        const isSinglePromotion = !!input_params.promotion_id;
        let promptMessage: string;

        if (isSinglePromotion) {
            promptMessage = `Generate fake data for an active promotion with ID '${input_params.promotion_id}'.
  The output should be an object with an 'items' property, where 'items' is an array containing exactly one promotion object.
  This promotion object should include: promotion_id, promotion_name, code, discount_type, discount_value, end_date, orders_using_promotion, revenue_from_promotion, average_items_per_promoted_order, and a list of top_product_ids_sold_with_promotion.
  Ensure 'is_active' would be true for this promotion and the details are plausible.`;
        } else {
            promptMessage = `Generate fake data for a list of 2-3 active e-commerce promotions.
  The output should be an object with an 'items' property, where 'items' is an array of these promotion objects.
  For each promotion object in the array, include: promotion_id, promotion_name, code, discount_type, discount_value, end_date, orders_using_promotion, revenue_from_promotion, average_items_per_promoted_order, and a list of top_product_ids_sold_with_promotion.
  Ensure 'is_active' would be true for these promotions and the details are plausible.`;
        }

        const { object: generatedData } = await generateObject({
            model: getDataGenerationLLM(), // Replace with your actual model instance
            schema: GetActivePromotionsOverviewOutputSchema,
            prompt: promptMessage,
        });
        return generatedData;
    },
});

// 4. getCustomerSegmentAnalysis
const GetCustomerSegmentAnalysisInputSchema = z.object({
    period_start_date: z.string().date().describe('Start date for the analysis period (YYYY-MM-DD).'),
    period_end_date: z.string().date().describe('End date for the analysis period (YYYY-MM-DD).'),
});

const GetCustomerSegmentAnalysisOutputSchema = z.object({
    items: z.array(z.object({
        segment_name: CustomerSchema.shape.segment,
        total_customers_in_segment: z.number().int().nonnegative().describe('Number of unique customers in this segment.'),
        total_revenue_from_segment: z.number().nonnegative().describe('Total revenue generated by customers in this segment during the period.'),
        average_order_value_for_segment: z.number().nonnegative().describe('Average order value for customers in this segment.'),
        most_purchased_category_by_segment: ProductSchema.shape.category.describe('The product category most frequently purchased by this segment.'),
    }))
});

const getCustomerSegmentAnalysisTool = tool({
    type: 'function',
    description: "Provides sales analysis based on different customer segments (e.g., VIP, New, Frequent Buyer) for a given period.",
    parameters: GetCustomerSegmentAnalysisInputSchema,
    execute: async (input_params) => {
        const { object: generatedData } = await generateObject({
            model: getDataGenerationLLM(), // Replace
            schema: GetCustomerSegmentAnalysisOutputSchema,
            prompt: `Generate a fake customer segment analysis for an e-commerce store.
        The period is from ${input_params.period_start_date} to ${input_params.period_end_date}.
        Include data for 3-4 customer segments (like VIP, New, Frequent Buyer, Lapsed).
        For each segment, provide plausible total customers, revenue, AOV, and their top purchased category.`,
        });
        return generatedData;
    },
});


// --- C. Shipping / Dispatch Manager Tools ---

// 1. getOrdersAwaitingDispatch
const GetOrdersAwaitingDispatchInputSchema = z.object({
    warehouse_id: z.string().optional().describe('Optional: Filter orders by the warehouse they should be dispatched from.'),
    priority: z.enum(['high', 'normal', 'low']).optional().describe('Optional: Filter by dispatch priority (e.g., express orders).'),
    limit: z.number().int().positive().optional().default(20).describe('Maximum number of orders to return.'),
});

const GetOrdersAwaitingDispatchOutputSchema = z.object({
    items: z.array(z.object({
        order_id: OrderSchema.shape.order_id,
        order_date: OrderSchema.shape.order_date,
        customer_name: z.string().describe("Customer's full name."),
        shipping_city: AddressSchema.shape.city,
        shipping_country: AddressSchema.shape.country,
        items_in_order: z.array(OrderItemBasicInfoSchema).describe('List of items in this order.'),
        total_weight_kg_estimate: z.number().positive().describe('Estimated total weight of the package in kilograms.'),
        requested_shipping_method: z.string().optional().describe('Shipping method requested by customer, e.g., Express, Standard.'),
        status: OrderSchema.shape.status.default('Awaiting Shipment').describe('Order status, should be primarily "Awaiting Shipment" or "Processing".'),
    }))
});

const getOrdersAwaitingDispatchTool = tool({
    type: 'function',
    description: "Retrieves a list of orders that are confirmed and awaiting shipment, including item details. Key for daily dispatch planning.",
    parameters: GetOrdersAwaitingDispatchInputSchema,
    execute: async (input_params) => {
        const { object: generatedData } = await generateObject({
            model: getDataGenerationLLM(), // Replace
            schema: GetOrdersAwaitingDispatchOutputSchema,
            prompt: `Generate a list of ${input_params.limit || 20} fake e-commerce orders that are awaiting dispatch.
        ${input_params.warehouse_id ? `These orders should be from warehouse ${input_params.warehouse_id}.` : ''}
        ${input_params.priority ? `Consider them as ${input_params.priority} priority.` : ''}
        For each order, include order ID, date, customer name, shipping destination, a list of items_in_order (each with product_id, product_name, sku, quantity), estimated total weight, and requested shipping method. Status should be 'Awaiting Shipment' or 'Processing'.`,
        });
        return generatedData;
    },
});


// 2. getShipmentStatusOverview
const GetShipmentStatusOverviewInputSchema = z.object({
    warehouse_id: z.string().optional().describe('Optional: Filter overview by origin warehouse ID.'),
});

const GetShipmentStatusOverviewOutputSchema = z.object({
    total_shipments_today: z.number().int().nonnegative().describe('Total packages shipped out today so far.'),
    shipments_in_transit: z.number().int().nonnegative().describe('Number of packages currently in transit to customers.'),
    shipments_delayed: z.number().int().nonnegative().describe('Number of packages currently marked as delayed.'),
    shipments_out_for_delivery: z.number().int().nonnegative().describe('Number of packages currently out for delivery today.'),
    shipments_delivered_today: z.number().int().nonnegative().describe('Number of packages confirmed delivered today.'),
    average_dispatch_time_hours_today: z.number().nonnegative().optional().describe('Average time taken from order confirmation to dispatch for packages sent today (in hours).'),
});

const getShipmentStatusOverviewTool = tool({
    type: 'function',
    description: "Provides an overview of current shipment statuses (in transit, delayed, delivered today, etc.). Good for a snapshot of shipping operations.",
    parameters: GetShipmentStatusOverviewInputSchema,
    execute: async (input_params) => {
        const { object: generatedData } = await generateObject({
            model: getDataGenerationLLM(), // Replace
            schema: GetShipmentStatusOverviewOutputSchema,
            prompt: `Generate a fake shipment status overview for an e-commerce dispatch manager.
              ${input_params.warehouse_id ? `Focus on shipments originating from warehouse ${input_params.warehouse_id}.` : ''}
              Provide plausible counts for shipments in various states (in transit, delayed, out for delivery, delivered today) and an optional average dispatch time for today.`,
        });
        return generatedData;
    },
});

// 3. getShipmentDetails
const GetShipmentDetailsInputSchema = z.object({
    shipment_id: z.string().optional().describe('Get details by shipment ID.'),
    order_id: z.string().optional().describe('Get shipment details for a given order ID (might return multiple if order split).'),
    tracking_number: z.string().optional().describe('Get shipment details by tracking number.'),
}).refine(
    (data) => (data.shipment_id || data.order_id || data.tracking_number) &&
        !(data.shipment_id && data.order_id) &&
        !(data.shipment_id && data.tracking_number) &&
        !(data.order_id && data.tracking_number),
    { message: "Provide exactly one of: shipment_id, order_id, or tracking_number." }
);

const ShipmentDetailSchema = z.object({
    shipment_id: ShipmentSchema.shape.shipment_id,
    order_id: ShipmentSchema.shape.order_id,
    customer_name: z.string().describe("Full name of the customer receiving the shipment."),
    carrier_name: ShipmentSchema.shape.carrier_name,
    tracking_number: ShipmentSchema.shape.tracking_number,
    status: ShipmentSchema.shape.status,
    dispatch_date: ShipmentSchema.shape.dispatch_date,
    estimated_delivery_date: ShipmentSchema.shape.estimated_delivery_date,
    actual_delivery_date: ShipmentSchema.shape.actual_delivery_date,
    current_location_notes: z.string().optional().describe('Textual update on current location, e.g., "Last seen: Memphis, TN Hub".'),
    shipping_address: AddressSchema.describe('The full shipping address for this shipment.'),
    shipped_items: z.array(OrderItemBasicInfoSchema).describe('List of items included in this specific shipment, with product_id, product_name, sku, and quantity for each.'),
});

const GetShipmentDetailsOutputSchema = z.object({
    items: z.array(ShipmentDetailSchema).describe('A list of shipment details. Will contain one or more items based on the identifier used.')
});

const getShipmentDetailsTool = tool({
    type: 'function',
    description: "Gets detailed information for a specific shipment or all shipments related to an order, including the items in the shipment. Returns an object with an 'items' array. Use one identifier: shipment_id, order_id, or tracking_number.",
    parameters: GetShipmentDetailsInputSchema,
    execute: async (input_params) => {
        const identifierUsed = input_params.shipment_id ? `shipment ID ${input_params.shipment_id}` :
            input_params.order_id ? `order ID ${input_params.order_id}` :
                `tracking number ${input_params.tracking_number}`;

        let promptMessage: string;

        if (input_params.order_id) {
            promptMessage = `Generate fake detailed shipment information for ${identifierUsed}.
  The output must be an object with an 'items' property, where 'items' is an array.
  This 'items' array should contain one or possibly two shipment objects if the order was split.
  Each shipment object in the array must include: shipment_id, order_id, customer_name, carrier_name, tracking_number, status, relevant dates (dispatch_date, estimated_delivery_date, actual_delivery_date), current_location_notes, the full shipping_address, and a list of shipped_items (each with product_id, product_name, sku, and quantity).
  Make the data look like real tracking information.`;
        } else {
            promptMessage = `Generate fake detailed shipment information for ${identifierUsed}.
  The output must be an object with an 'items' property, where 'items' is an array containing exactly one shipment object.
  This shipment object must include: shipment_id, order_id, customer_name, carrier_name, tracking_number, status, relevant dates (dispatch_date, estimated_delivery_date, actual_delivery_date), current_location_notes, the full shipping_address, and a list of shipped_items (each with product_id, product_name, sku, and quantity).
  Make the data look like real tracking information.`;
        }

        const { object: generatedData } = await generateObject({
            model: getDataGenerationLLM(),
            schema: GetShipmentDetailsOutputSchema,
            prompt: promptMessage,
        });
        return generatedData;
    },
});

// 4. getCarrierPerformanceSummary
const GetCarrierPerformanceSummaryInputSchema = z.object({
    period_start_date: z.string().date().describe('Start date for the performance period (YYYY-MM-DD).'),
    period_end_date: z.string().date().describe('End date for the performance period (YYYY-MM-DD).'),
});

const GetCarrierPerformanceSummaryOutputSchema = z.object({
    items: z.array(z.object({
        carrier_name: ShipmentSchema.shape.carrier_name,
        total_shipments_handled: z.number().int().nonnegative().describe('Total shipments handled by this carrier in the period.'),
        on_time_delivery_percentage: z.number().min(0).max(100).describe('Percentage of shipments delivered on time by this carrier.'),
        average_shipping_cost_per_package: z.number().nonnegative().describe('Average cost charged by this carrier per package.'),
        damage_rate_percentage: z.number().min(0).max(100).optional().describe('Percentage of packages reported damaged with this carrier.'),
    }))
});

const getCarrierPerformanceSummaryTool = tool({
    type: 'function',
    description: "Summarizes performance metrics for shipping carriers used during a specific period. Helps evaluate carrier effectiveness.",
    parameters: GetCarrierPerformanceSummaryInputSchema,
    execute: async (input_params) => {
        const { object: generatedData } = await generateObject({
            model: getDataGenerationLLM(), // Replace
            schema: GetCarrierPerformanceSummaryOutputSchema,
            prompt: `Generate a fake performance summary for 2-3 shipping carriers (e.g., FedEx, UPS, DHL).
        The period is from ${input_params.period_start_date} to ${input_params.period_end_date}.
        For each carrier, include plausible total shipments, on-time delivery rate, average cost per package, and an optional damage rate.`,
        });
        return generatedData;
    },
});

export const ECommerceTools = {
    getLowStockProducts: getLowStockProductsTool,
    getInventorySummary: getInventorySummaryTool,
    getProductStockDetails: getProductStockDetailsTool,
    getSupplierPerformanceMetrics: getSupplierPerformanceMetricsTool,

    getSalesPerformanceSummary: getSalesPerformanceSummaryTool,
    getTopPerformingProductsBySales: getTopPerformingProductsBySalesTool,
    getActivePromotionsOverview: getActivePromotionsOverviewTool,
    getCustomerSegmentAnalysis: getCustomerSegmentAnalysisTool,

    getOrdersAwaitingDispatch: getOrdersAwaitingDispatchTool,
    getShipmentStatusOverview: getShipmentStatusOverviewTool,
    getShipmentDetails: getShipmentDetailsTool,
    getCarrierPerformanceSummary: getCarrierPerformanceSummaryTool,
};